{
  "language": "Solidity",
  "sources": {
    "contracts/Cemetery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// 基础库\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// 计数器库\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n\n// 墓地合约\ncontract Cemetery is Ownable {\n    using Counters for Counters.Counter;\n    \n    Counters.Counter private _plotIds;\n    \n    enum PlotStatus {\n        AVAILABLE,  // 可用\n        RESERVED,   // 已预订\n        OCCUPIED    // 已占用\n    }\n    \n    enum PlotType {\n        STANDARD,   // 标准墓位\n        PREMIUM,    // 高级墓位\n        FAMILY      // 家族墓位\n    }\n    \n    struct Plot {\n        uint256 id;\n        PlotType plotType;\n        PlotStatus status;\n        uint256 price;\n        string location;\n        address owner;\n        string occupantName;\n        uint256 burialDate;\n        string epitaph;\n    }\n    \n    struct BurialRecord {\n        uint256 plotId;\n        string deceasedName;\n        address familyContact;\n        uint256 burialDate;\n        string ceremony;\n    }\n    \n    mapping(uint256 => Plot) public plots;\n    mapping(address => uint256[]) public familyPlots;\n    mapping(string => BurialRecord) public burialRecords; // 按姓名索引\n    \n    address public funeralServiceContract;\n    \n    event PlotPurchased(uint256 indexed plotId, address buyer, string location);\n    event BurialScheduled(string deceasedName, uint256 plotId, uint256 burialDate);\n    event BurialCompleted(string deceasedName, uint256 plotId);\n    \n    constructor() {\n        // 初始化一些墓位\n        _initializePlots();\n    }\n    \n    function _initializePlots() internal {\n        // 创建标准墓位\n        for (uint256 i = 1; i <= 50; i++) {\n            _plotIds.increment();\n            uint256 plotId = _plotIds.current();\n            plots[plotId] = Plot({\n                id: plotId,\n                plotType: PlotType.STANDARD,\n                status: PlotStatus.AVAILABLE,\n                price: 1 ether,\n                location: string(abi.encodePacked(\"Section A, Plot \", _toString(i))),\n                owner: address(0),\n                occupantName: \"\",\n                burialDate: 0,\n                epitaph: \"\"\n            });\n        }\n        \n        // 创建高级墓位\n        for (uint256 i = 1; i <= 30; i++) {\n            _plotIds.increment();\n            uint256 plotId = _plotIds.current();\n            plots[plotId] = Plot({\n                id: plotId,\n                plotType: PlotType.PREMIUM,\n                status: PlotStatus.AVAILABLE,\n                price: 3 ether,\n                location: string(abi.encodePacked(\"Section B, Plot \", _toString(i))),\n                owner: address(0),\n                occupantName: \"\",\n                burialDate: 0,\n                epitaph: \"\"\n            });\n        }\n        \n        // 创建家族墓位\n        for (uint256 i = 1; i <= 10; i++) {\n            _plotIds.increment();\n            uint256 plotId = _plotIds.current();\n            plots[plotId] = Plot({\n                id: plotId,\n                plotType: PlotType.FAMILY,\n                status: PlotStatus.AVAILABLE,\n                price: 5 ether,\n                location: string(abi.encodePacked(\"Section C, Plot \", _toString(i))),\n                owner: address(0),\n                occupantName: \"\",\n                burialDate: 0,\n                epitaph: \"\"\n            });\n        }\n    }\n    \n    function _toString(uint256 value) internal pure returns (string memory) {\n        // 简单的数字转字符串函数\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    function setFuneralServiceContract(address _funeralService) external onlyOwner {\n        funeralServiceContract = _funeralService;\n    }\n    \n    // 购买墓位\n    function purchasePlot(uint256 _plotId) external payable {\n        require(_plotId <= _plotIds.current(), \"Plot does not exist\");\n        Plot storage plot = plots[_plotId];\n        require(plot.status == PlotStatus.AVAILABLE, \"Plot not available\");\n        require(msg.value >= plot.price, \"Insufficient payment\");\n        \n        plot.status = PlotStatus.RESERVED;\n        plot.owner = msg.sender;\n        \n        familyPlots[msg.sender].push(_plotId);\n        \n        // 退还多余的ETH\n        if (msg.value > plot.price) {\n            payable(msg.sender).transfer(msg.value - plot.price);\n        }\n        \n        emit PlotPurchased(_plotId, msg.sender, plot.location);\n    }\n    \n    // 准备安葬（由殡葬服务合约调用）\n    function prepareBurial(\n        string memory _deceasedName,\n        address _familyContact,\n        uint256 _burialDate\n    ) external {\n        require(msg.sender == funeralServiceContract, \"Only funeral service can call\");\n        \n        // 查找该家庭拥有的墓位\n        uint256[] memory ownedPlots = familyPlots[_familyContact];\n        require(ownedPlots.length > 0, \"Family has no plots\");\n        \n        // 找到一个已预订但未占用的墓位\n        uint256 plotId = 0;\n        for (uint256 i = 0; i < ownedPlots.length; i++) {\n            if (plots[ownedPlots[i]].status == PlotStatus.RESERVED) {\n                plotId = ownedPlots[i];\n                break;\n            }\n        }\n        \n        require(plotId > 0, \"No reserved plots available\");\n        \n        Plot storage plot = plots[plotId];\n        plot.occupantName = _deceasedName;\n        plot.burialDate = _burialDate;\n        plot.status = PlotStatus.OCCUPIED;\n        \n        // 记录安葬信息\n        burialRecords[_deceasedName] = BurialRecord({\n            plotId: plotId,\n            deceasedName: _deceasedName,\n            familyContact: _familyContact,\n            burialDate: _burialDate,\n            ceremony: \"Standard\"\n        });\n        \n        emit BurialScheduled(_deceasedName, plotId, _burialDate);\n    }\n    \n    // 设置墓志铭\n    function setEpitaph(uint256 _plotId, string memory _epitaph) external {\n        require(_plotId <= _plotIds.current(), \"Plot does not exist\");\n        Plot storage plot = plots[_plotId];\n        require(plot.owner == msg.sender, \"Not the plot owner\");\n        require(plot.status == PlotStatus.OCCUPIED, \"Plot not occupied\");\n        \n        plot.epitaph = _epitaph;\n    }\n    \n    // 获取墓位信息\n    function getPlot(uint256 _plotId) external view returns (Plot memory) {\n        require(_plotId <= _plotIds.current(), \"Plot does not exist\");\n        return plots[_plotId];\n    }\n    \n    // 提取资金\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n}"
    },
    "contracts/FuneralService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// 基础库\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// 防重入保护\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n// 计数器库\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n\n// 墓地接口\ninterface ICemetery {\n    function prepareBurial(\n        string memory _deceasedName,\n        address _familyContact,\n        uint256 _burialDate\n    ) external;\n}\n\n// 殡葬服务合约\ncontract FuneralService is Ownable, ReentrancyGuard {\n    using Counters for Counters.Counter;\n    \n    Counters.Counter private _serviceIds;\n    \n    enum ServiceStatus {\n        INITIATED,    // 已启动\n        CONFIRMED,    // 已确认\n        IN_PROGRESS, // 进行中\n        COMPLETED    // 已完成\n    }\n    \n    enum ServiceType {\n        BASIC,       // 基础服务\n        STANDARD,    // 标准服务\n        PREMIUM      // 高端服务\n    }\n    \n    struct FuneralOrder {\n        uint256 id;\n        uint256 patientId;\n        string deceasedName;\n        address familyContact;\n        ServiceType serviceType;\n        ServiceStatus status;\n        uint256 totalCost;\n        uint256 initiatedTime;\n        uint256 serviceDate;\n        string specialRequests;\n        bool isPaid;\n    }\n    \n    mapping(uint256 => FuneralOrder) public funeralOrders;\n    mapping(ServiceType => uint256) public servicePrices;\n    \n    address public hospitalContract;\n    address public cemeteryContract;\n    \n    event FuneralInitiated(uint256 indexed orderId, uint256 patientId, string deceasedName);\n    event ServiceConfirmed(uint256 indexed orderId, ServiceType serviceType);\n    event ServiceCompleted(uint256 indexed orderId);\n    event PaymentReceived(uint256 indexed orderId, uint256 amount);\n    \n    constructor() {\n        // 设置默认价格（以wei为单位）\n        servicePrices[ServiceType.BASIC] = 5 ether;\n        servicePrices[ServiceType.STANDARD] = 10 ether;\n        servicePrices[ServiceType.PREMIUM] = 20 ether;\n    }\n    \n    function setExternalContracts(address _hospital, address _cemetery) external onlyOwner {\n        hospitalContract = _hospital;\n        cemeteryContract = _cemetery;\n    }\n    \n    function updateServicePrice(ServiceType _type, uint256 _price) external onlyOwner {\n        servicePrices[_type] = _price;\n    }\n    \n    // 由医院合约调用，启动殡葬流程\n    function initiateFuneralProcess(\n        uint256 _patientId,\n        string memory _deceasedName,\n        address _familyContact\n    ) external returns (uint256) {\n        require(msg.sender == hospitalContract, \"Only hospital can initiate\");\n        \n        _serviceIds.increment();\n        uint256 newOrderId = _serviceIds.current();\n        \n        funeralOrders[newOrderId] = FuneralOrder({\n            id: newOrderId,\n            patientId: _patientId,\n            deceasedName: _deceasedName,\n            familyContact: _familyContact,\n            serviceType: ServiceType.BASIC, // 默认基础服务\n            status: ServiceStatus.INITIATED,\n            totalCost: servicePrices[ServiceType.BASIC],\n            initiatedTime: block.timestamp,\n            serviceDate: 0,\n            specialRequests: \"\",\n            isPaid: false\n        });\n        \n        emit FuneralInitiated(newOrderId, _patientId, _deceasedName);\n        return newOrderId;\n    }\n    \n    // 家属确认服务类型\n    function confirmService(\n        uint256 _orderId,\n        ServiceType _serviceType,\n        uint256 _serviceDate,\n        string memory _specialRequests\n    ) external payable {\n        FuneralOrder storage order = funeralOrders[_orderId];\n        require(msg.sender == order.familyContact, \"Only family can confirm\");\n        require(order.status == ServiceStatus.INITIATED, \"Invalid status\");\n        \n        order.serviceType = _serviceType;\n        order.totalCost = servicePrices[_serviceType];\n        order.serviceDate = _serviceDate;\n        order.specialRequests = _specialRequests;\n        order.status = ServiceStatus.CONFIRMED;\n        \n        // 检查支付\n        if (msg.value >= order.totalCost) {\n            order.isPaid = true;\n            emit PaymentReceived(_orderId, msg.value);\n            \n            // 退还多余金额\n            if (msg.value > order.totalCost) {\n                payable(msg.sender).transfer(msg.value - order.totalCost);\n            }\n        }\n        \n        emit ServiceConfirmed(_orderId, _serviceType);\n    }\n    \n    // 开始服务\n    function startService(uint256 _orderId) external onlyOwner {\n        FuneralOrder storage order = funeralOrders[_orderId];\n        require(order.status == ServiceStatus.CONFIRMED, \"Service not confirmed\");\n        require(order.isPaid, \"Payment not received\");\n        \n        order.status = ServiceStatus.IN_PROGRESS;\n    }\n    \n    // 完成服务\n    function completeService(uint256 _orderId) external onlyOwner {\n        FuneralOrder storage order = funeralOrders[_orderId];\n        require(order.status == ServiceStatus.IN_PROGRESS, \"Service not in progress\");\n        \n        order.status = ServiceStatus.COMPLETED;\n        \n        // 通知墓地合约准备安葬\n        if (cemeteryContract != address(0)) {\n            ICemetery(cemeteryContract).prepareBurial(\n                order.deceasedName,\n                order.familyContact,\n                order.serviceDate\n            );\n        }\n        \n        emit ServiceCompleted(_orderId);\n    }\n    \n    function getFuneralOrder(uint256 _orderId) external view returns (FuneralOrder memory) {\n        return funeralOrders[_orderId];\n    }\n    \n    // 提取收入\n    function withdraw() external onlyOwner nonReentrant {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n}"
    },
    "contracts/HospitalCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// 基础库\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// 防重入保护\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n// 计数器库\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n\n// 殡葬服务接口\ninterface IFuneralService {\n    function initiateFuneralProcess(\n        uint256 _patientId,\n        string memory _deceasedName,\n        address _familyContact\n    ) external returns (uint256);\n}\n\n// 核心医院合约\ncontract HospitalCore is Ownable, ReentrancyGuard {\n    using Counters for Counters.Counter;\n    \n    Counters.Counter private _patientIds;\n    \n    // 患者状态枚举\n    enum PatientStatus { \n        ADMITTED,           // 入院\n        IN_TREATMENT,      // 治疗中\n        CRITICAL,          // 危重\n        STABLE,            // 稳定\n        DISCHARGED,        // 出院\n        DECEASED           // 去世\n    }\n    \n    // 患者信息结构\n    struct Patient {\n        uint256 id;\n        string name;\n        uint256 age;\n        address familyContact;\n        PatientStatus status;\n        uint256 admissionTime;\n        uint256 lastUpdateTime;\n        string medicalRecord;\n        bool hasFuneralPlan;\n    }\n    \n    // 存储结构\n    mapping(uint256 => Patient) public patients;\n    mapping(address => uint256[]) public familyPatients;\n    \n    // 关联的外部服务合约\n    address public nursingHomeContract;\n    address public funeralServiceContract;\n    address public cemeteryContract;\n    \n    // 事件定义\n    event PatientAdmitted(uint256 indexed patientId, string name, address familyContact);\n    event PatientStatusUpdated(uint256 indexed patientId, PatientStatus newStatus);\n    event PatientDeceased(uint256 indexed patientId, uint256 timestamp);\n    event FuneralServiceTriggered(uint256 indexed patientId, address funeralContract);\n    \n    // 修饰符：仅限医护人员\n    modifier onlyMedicalStaff() {\n        require(medicalStaff[msg.sender], \"Only medical staff can perform this action\");\n        _;\n    }\n    \n    mapping(address => bool) public medicalStaff;\n    \n    constructor() {\n        medicalStaff[msg.sender] = true;\n    }\n    \n    // 添加医护人员\n    function addMedicalStaff(address staff) external onlyOwner {\n        medicalStaff[staff] = true;\n    }\n    \n    // 设置外部服务合约地址\n    function setExternalContracts(\n        address _nursingHome,\n        address _funeralService,\n        address _cemetery\n    ) external onlyOwner {\n        nursingHomeContract = _nursingHome;\n        funeralServiceContract = _funeralService;\n        cemeteryContract = _cemetery;\n    }\n    \n    // 患者入院登记\n    function admitPatient(\n        string memory _name,\n        uint256 _age,\n        address _familyContact,\n        string memory _initialRecord\n    ) external onlyMedicalStaff returns (uint256) {\n        _patientIds.increment();\n        uint256 newPatientId = _patientIds.current();\n        \n        patients[newPatientId] = Patient({\n            id: newPatientId,\n            name: _name,\n            age: _age,\n            familyContact: _familyContact,\n            status: PatientStatus.ADMITTED,\n            admissionTime: block.timestamp,\n            lastUpdateTime: block.timestamp,\n            medicalRecord: _initialRecord,\n            hasFuneralPlan: false\n        });\n        \n        familyPatients[_familyContact].push(newPatientId);\n        \n        emit PatientAdmitted(newPatientId, _name, _familyContact);\n        return newPatientId;\n    }\n    \n    // 更新患者状态\n    function updatePatientStatus(\n        uint256 _patientId,\n        PatientStatus _newStatus,\n        string memory _updateRecord\n    ) external onlyMedicalStaff {\n        require(_patientId <= _patientIds.current(), \"Patient does not exist\");\n        \n        Patient storage patient = patients[_patientId];\n        patient.status = _newStatus;\n        patient.lastUpdateTime = block.timestamp;\n        patient.medicalRecord = string(abi.encodePacked(\n            patient.medicalRecord, \n            \" | \", \n            _updateRecord\n        ));\n        \n        emit PatientStatusUpdated(_patientId, _newStatus);\n        \n        // 如果患者去世，自动触发殡葬服务\n        if (_newStatus == PatientStatus.DECEASED) {\n            _handlePatientDeceased(_patientId);\n        }\n    }\n    \n    // 处理患者去世情况\n    function _handlePatientDeceased(uint256 _patientId) internal {\n        Patient storage patient = patients[_patientId];\n        \n        emit PatientDeceased(_patientId, block.timestamp);\n        \n        // 自动联系殡葬服务\n        if (funeralServiceContract != address(0)) {\n            IFuneralService(funeralServiceContract).initiateFuneralProcess(\n                _patientId,\n                patient.name,\n                patient.familyContact\n            );\n            emit FuneralServiceTriggered(_patientId, funeralServiceContract);\n        }\n    }\n    \n    // 获取患者信息\n    function getPatient(uint256 _patientId) external view returns (Patient memory) {\n        require(_patientId <= _patientIds.current(), \"Patient does not exist\");\n        return patients[_patientId];\n    }\n    \n    // 获取家属的所有患者\n    function getFamilyPatients(address _family) external view returns (uint256[] memory) {\n        return familyPatients[_family];\n    }\n    \n    // 获取当前患者总数\n    function getTotalPatients() external view returns (uint256) {\n        return _patientIds.current();\n    }\n\n    // 支付治疗费用\n    function payForTreatment(uint256 _patientId) external payable {\n        require(_patientId <= _patientIds.current(), \"Patient does not exist\");\n        // 这里可以添加更多的支付逻辑\n    }\n\n    // 提取资金\n    function withdraw() external onlyOwner nonReentrant {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n        payable(owner()).transfer(balance);\n    }\n}"
    },
    "contracts/NursingHome.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// 基础库\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// 计数器库\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n\n// 医院接口\ninterface IHospitalCore {\n    function admitPatient(\n        string memory _name,\n        uint256 _age,\n        address _familyContact,\n        string memory _initialRecord\n    ) external returns (uint256);\n}\n\n// 养老院合约\ncontract NursingHome is Ownable {\n    using Counters for Counters.Counter;\n    \n    Counters.Counter private _residentIds;\n    \n    enum ResidentStatus {\n        ACTIVE,      // 在院\n        TRANSFERRED, // 转院\n        DECEASED     // 去世\n    }\n    \n    struct Resident {\n        uint256 id;\n        string name;\n        uint256 age;\n        address familyContact;\n        ResidentStatus status;\n        uint256 admissionDate;\n        uint256 monthlyFee;\n        string healthCondition;\n    }\n    \n    mapping(uint256 => Resident) public residents;\n    mapping(address => uint256[]) public familyResidents;\n    \n    address public hospitalContract;\n    \n    event ResidentAdmitted(uint256 indexed residentId, string name);\n    event ResidentTransferred(uint256 indexed residentId, address hospital);\n    event ResidentDeceased(uint256 indexed residentId);\n    \n    function setHospitalContract(address _hospital) external onlyOwner {\n        hospitalContract = _hospital;\n    }\n    \n    function admitResident(\n        string memory _name,\n        uint256 _age,\n        address _familyContact,\n        uint256 _monthlyFee,\n        string memory _healthCondition\n    ) external onlyOwner returns (uint256) {\n        _residentIds.increment();\n        uint256 newResidentId = _residentIds.current();\n        \n        residents[newResidentId] = Resident({\n            id: newResidentId,\n            name: _name,\n            age: _age,\n            familyContact: _familyContact,\n            status: ResidentStatus.ACTIVE,\n            admissionDate: block.timestamp,\n            monthlyFee: _monthlyFee,\n            healthCondition: _healthCondition\n        });\n        \n        familyResidents[_familyContact].push(newResidentId);\n        emit ResidentAdmitted(newResidentId, _name);\n        return newResidentId;\n    }\n    \n    // 转院到医院\n    function transferToHospital(\n        uint256 _residentId,\n        string memory _reason\n    ) external onlyOwner {\n        require(_residentId <= _residentIds.current(), \"Resident does not exist\");\n        Resident storage resident = residents[_residentId];\n        require(resident.status == ResidentStatus.ACTIVE, \"Resident not active\");\n        \n        resident.status = ResidentStatus.TRANSFERRED;\n        \n        // 调用医院合约进行入院登记\n        if (hospitalContract != address(0)) {\n            IHospitalCore(hospitalContract).admitPatient(\n                resident.name,\n                resident.age,\n                resident.familyContact,\n                string(abi.encodePacked(\"Transferred from nursing home: \", _reason))\n            );\n        }\n        \n        emit ResidentTransferred(_residentId, hospitalContract);\n    }\n    \n    function getResident(uint256 _residentId) external view returns (Resident memory) {\n        return residents[_residentId];\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}